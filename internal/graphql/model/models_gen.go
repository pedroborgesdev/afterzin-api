// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"bytes"
	"fmt"
	"io"
	"strconv"
)

type AuthPayload struct {
	Token string `json:"token"`
	User  *User  `json:"user"`
}

// Input para criação de sessão de checkout.
// Cria uma ordem pendente (PENDING) com expiração de 30 minutos.
type CheckoutInput struct {
	// Lista de itens a serem comprados (não pode estar vazia)
	Items []*CheckoutItemInput `json:"items"`
}

// Input para seleção de ingressos no checkout.
// Cada item representa um tipo de ingresso para uma data específica do evento.
type CheckoutItemInput struct {
	// ID da data do evento (EventDate)
	EventDateID string `json:"eventDateId"`
	// ID do tipo de ingresso (TicketType)
	TicketTypeID string `json:"ticketTypeId"`
	// Quantidade de ingressos (1-10)
	Quantity int `json:"quantity"`
}

// Input para confirmação de pagamento de checkout.
// IMPORTANTE: Apenas pagamento via PIX é aceito.
type CheckoutPayInput struct {
	// ID do checkout retornado pelo checkoutPreview
	CheckoutID string `json:"checkoutId"`
}

type CheckoutPayResult struct {
	Success       bool     `json:"success"`
	TicketIds     []string `json:"ticketIds,omitempty"`
	QRCodePayload *string  `json:"qrCodePayload,omitempty"`
	QRCodeNumber  *string  `json:"qrCodeNumber,omitempty"`
	Message       *string  `json:"message,omitempty"`
}

type CheckoutPreviewItem struct {
	EventTitle     string  `json:"eventTitle"`
	EventDate      string  `json:"eventDate"`
	TicketTypeName string  `json:"ticketTypeName"`
	Quantity       int     `json:"quantity"`
	UnitPrice      float64 `json:"unitPrice"`
	Subtotal       float64 `json:"subtotal"`
}

type CheckoutPreviewResult struct {
	CheckoutID string                 `json:"checkoutId"`
	Total      float64                `json:"total"`
	Items      []*CheckoutPreviewItem `json:"items"`
}

type CreateEventInput struct {
	Title       string  `json:"title"`
	Description string  `json:"description"`
	Category    string  `json:"category"`
	CoverImage  string  `json:"coverImage"`
	Location    string  `json:"location"`
	Address     *string `json:"address,omitempty"`
}

type Event struct {
	ID          string       `json:"id"`
	Title       string       `json:"title"`
	Description string       `json:"description"`
	Category    string       `json:"category"`
	CoverImage  string       `json:"coverImage"`
	Location    string       `json:"location"`
	Address     *string      `json:"address,omitempty"`
	Status      EventStatus  `json:"status"`
	Dates       []*EventDate `json:"dates"`
	Producer    *Producer    `json:"producer"`
	Featured    *bool        `json:"featured,omitempty"`
}

type EventDate struct {
	ID        string  `json:"id"`
	EventID   string  `json:"eventId"`
	Date      string  `json:"date"`
	StartTime *string `json:"startTime,omitempty"`
	EndTime   *string `json:"endTime,omitempty"`
	Lots      []*Lot  `json:"lots"`
}

type EventDateInput struct {
	Date      string  `json:"date"`
	StartTime *string `json:"startTime,omitempty"`
	EndTime   *string `json:"endTime,omitempty"`
}

type EventFilter struct {
	Category *string `json:"category,omitempty"`
	Date     *string `json:"date,omitempty"`
	City     *string `json:"city,omitempty"`
}

type LoginInput struct {
	Email    string `json:"email"`
	Password string `json:"password"`
}

type Lot struct {
	ID                string        `json:"id"`
	Name              string        `json:"name"`
	StartsAt          string        `json:"startsAt"`
	EndsAt            string        `json:"endsAt"`
	TotalQuantity     int           `json:"totalQuantity"`
	AvailableQuantity int           `json:"availableQuantity"`
	Active            bool          `json:"active"`
	TicketTypes       []*TicketType `json:"ticketTypes"`
}

type LotInput struct {
	Name          string `json:"name"`
	StartsAt      string `json:"startsAt"`
	EndsAt        string `json:"endsAt"`
	TotalQuantity int    `json:"totalQuantity"`
}

type Mutation struct {
}

type Producer struct {
	ID          string  `json:"id"`
	User        *User   `json:"user"`
	CompanyName *string `json:"companyName,omitempty"`
	Approved    bool    `json:"approved"`
}

// Perfil público do produtor: dados do produtor + eventos publicados (excl. rascunho).
type ProducerPublicProfile struct {
	Producer *Producer `json:"producer"`
	Events   []*Event  `json:"events"`
}

type Query struct {
}

// Input para registro de novo usuário.
// Telefone é obrigatório para integração com gateway de pagamento.
type RegisterInput struct {
	Name             string `json:"name"`
	Email            string `json:"email"`
	Password         string `json:"password"`
	Cpf              string `json:"cpf"`
	BirthDate        string `json:"birthDate"`
	PhoneCountryCode string `json:"phoneCountryCode"`
	PhoneAreaCode    string `json:"phoneAreaCode"`
	PhoneNumber      string `json:"phoneNumber"`
}

type Ticket struct {
	ID         string      `json:"id"`
	Code       string      `json:"code"`
	QRCode     string      `json:"qrCode"`
	Event      *Event      `json:"event"`
	EventDate  *EventDate  `json:"eventDate"`
	TicketType *TicketType `json:"ticketType"`
	Owner      *User       `json:"owner"`
	Used       bool        `json:"used"`
	UsedAt     *string     `json:"usedAt,omitempty"`
	CreatedAt  string      `json:"createdAt"`
}

type TicketType struct {
	ID           string       `json:"id"`
	Name         string       `json:"name"`
	Description  *string      `json:"description,omitempty"`
	Price        float64      `json:"price"`
	Audience     AudienceType `json:"audience"`
	MaxQuantity  int          `json:"maxQuantity"`
	SoldQuantity int          `json:"soldQuantity"`
}

type TicketTypeInput struct {
	Name        string       `json:"name"`
	Description *string      `json:"description,omitempty"`
	Price       float64      `json:"price"`
	Audience    AudienceType `json:"audience"`
	MaxQuantity int          `json:"maxQuantity"`
}

type UpdateEventInput struct {
	Title       *string `json:"title,omitempty"`
	Description *string `json:"description,omitempty"`
	Category    *string `json:"category,omitempty"`
	CoverImage  *string `json:"coverImage,omitempty"`
	Location    *string `json:"location,omitempty"`
	Address     *string `json:"address,omitempty"`
}

type User struct {
	ID               string   `json:"id"`
	Name             string   `json:"name"`
	Email            string   `json:"email"`
	Cpf              string   `json:"cpf"`
	BirthDate        string   `json:"birthDate"`
	PhoneCountryCode *string  `json:"phoneCountryCode,omitempty"`
	PhoneAreaCode    *string  `json:"phoneAreaCode,omitempty"`
	PhoneNumber      *string  `json:"phoneNumber,omitempty"`
	PhotoURL         *string  `json:"photoUrl,omitempty"`
	Role             UserRole `json:"role"`
	CreatedAt        string   `json:"createdAt"`
}

// Resultado da validação de ingresso por QR Code.
type ValidateTicketResult struct {
	Success   bool    `json:"success"`
	Ticket    *Ticket `json:"ticket,omitempty"`
	ErrorCode *string `json:"errorCode,omitempty"`
	Message   *string `json:"message,omitempty"`
}

type AudienceType string

const (
	AudienceTypeGeneral AudienceType = "GENERAL"
	AudienceTypeMale    AudienceType = "MALE"
	AudienceTypeFemale  AudienceType = "FEMALE"
	AudienceTypeChild   AudienceType = "CHILD"
)

var AllAudienceType = []AudienceType{
	AudienceTypeGeneral,
	AudienceTypeMale,
	AudienceTypeFemale,
	AudienceTypeChild,
}

func (e AudienceType) IsValid() bool {
	switch e {
	case AudienceTypeGeneral, AudienceTypeMale, AudienceTypeFemale, AudienceTypeChild:
		return true
	}
	return false
}

func (e AudienceType) String() string {
	return string(e)
}

func (e *AudienceType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AudienceType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AudienceType", str)
	}
	return nil
}

func (e AudienceType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AudienceType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AudienceType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type EventStatus string

const (
	EventStatusDraft     EventStatus = "DRAFT"
	EventStatusPublished EventStatus = "PUBLISHED"
	EventStatusPaused    EventStatus = "PAUSED"
	EventStatusEnded     EventStatus = "ENDED"
)

var AllEventStatus = []EventStatus{
	EventStatusDraft,
	EventStatusPublished,
	EventStatusPaused,
	EventStatusEnded,
}

func (e EventStatus) IsValid() bool {
	switch e {
	case EventStatusDraft, EventStatusPublished, EventStatusPaused, EventStatusEnded:
		return true
	}
	return false
}

func (e EventStatus) String() string {
	return string(e)
}

func (e *EventStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EventStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EventStatus", str)
	}
	return nil
}

func (e EventStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *EventStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e EventStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type UserRole string

const (
	UserRoleUser     UserRole = "USER"
	UserRoleProducer UserRole = "PRODUCER"
	UserRoleAdmin    UserRole = "ADMIN"
)

var AllUserRole = []UserRole{
	UserRoleUser,
	UserRoleProducer,
	UserRoleAdmin,
}

func (e UserRole) IsValid() bool {
	switch e {
	case UserRoleUser, UserRoleProducer, UserRoleAdmin:
		return true
	}
	return false
}

func (e UserRole) String() string {
	return string(e)
}

func (e *UserRole) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserRole", str)
	}
	return nil
}

func (e UserRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *UserRole) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e UserRole) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}
